<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Latin Verb Practice Game</title>
  <!-- Google Fonts for a Classical Feel -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lora:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* Global and layout styling with classical colors and gradients */
    body {
      font-family: 'Lora', serif;
      background: linear-gradient(135deg, #fdf6e3, #f5e9d3); /* Parchment-like gradient */
      color: #4d3c2e; /* Dark brown text for a classical look */
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: #fffaf0; /* Off-white, parchment-like background */
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
      opacity: 1;
      transition: opacity 0.5s ease;
    }
    /* Fade-in and fade-out transitions */
    .fade-in {
      animation: fadeIn 0.5s forwards;
    }
    .fade-out {
      animation: fadeOut 0.5s forwards;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to   { opacity: 1; }
    }
    @keyframes fadeOut {
      from { opacity: 1; }
      to   { opacity: 0; }
    }
    
    h1, h2, h3 {
      margin-bottom: 15px;
      color: #3b2e1a; /* Deep brown */
    }
    h1 {
      font-family: 'Cinzel', serif;
      font-size: 36px;
      text-align: center;
    }
    h2 {
      font-family: 'Cinzel', serif;
      font-size: 30px;
      text-align: center;
    }
    h3 {
      font-size: 22px;
    }
    
    fieldset {
      border: 1px solid #c1a57b; /* Goldish brown */
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 6px;
      background: #fff8f0;
    }
    legend {
      font-weight: 700;
      font-size: 20px;
      padding: 0 5px;
      color: #3b2e1a;
    }
    .checkbox-group, .radio-group {
      display: inline-block;
      margin-right: 20px;
      font-size: 16px;
    }
    .input-group {
      margin-bottom: 20px;
    }
    input[type="text"] {
      width: 100%;
      max-width: 300px;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #c1a57b;
      border-radius: 4px;
    }
    
    button {
      padding: 10px 25px;
      font-size: 16px;
      cursor: pointer;
      background: linear-gradient(135deg, #b58900, #d33682); /* Gold to deep magenta accent */
      color: #fff;
      border: none;
      border-radius: 4px;
      transition: background 0.3s, transform 0.1s;
    }
    button:hover {
      background: linear-gradient(135deg, #a17a00, #b02e70);
    }
    button:active {
      transform: scale(0.98);
    }
    
    /* Option buttons styling with classical colors */
    .option-button {
      background: #fff;
      color: #3b2e1a;
      border: 1px solid #c1a57b;
      border-radius: 4px;
      padding: 8px 12px;
      margin: 5px;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
    }
    .option-button:hover {
      background: #fdf6e3;
    }
    .option-button:active {
      box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
    }
    .option-button.selected {
      background: #b58900;
      border-color: #3b2e1a;
      color: #fff;
    }
    
    .hidden {
      display: none;
    }
    
    #topBar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    #scoreDisplay, #timerDisplay {
      font-size: 18px;
      font-family: 'Cinzel', serif;
    }
    #verbFormDisplay {
      font-size: 36px;
      text-align: center;
      margin-bottom: 5px;
      font-family: 'Cinzel', serif;
    }
    #principalPartsDisplay {
      font-size: 14px;
      color: #7f6a55;
      text-align: center;
      margin-bottom: 25px;
    }
    .practice-option {
      margin-bottom: 20px;
      text-align: center;
    }
    #correctAnswerDisplay {
      text-align: center;
      margin-top: 15px;
      font-size: 16px;
      font-style: italic;
      color: #3b2e1a;
    }
    /* Final review table styling */
    #recordTable {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    #recordTable th, #recordTable td {
      border: 1px solid #c1a57b;
      padding: 8px;
      text-align: center;
    }
    #recordTable th {
      background: #fefcf4;
    }
    /* Confetti canvas style */
    .confetti {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9999;
    }
    /* Responsive design */
    @media (max-width: 600px) {
      .container {
        width: 90%;
        padding: 20px;
      }
      input[type="text"] {
        width: 100%;
      }
      button {
        width: 100%;
        box-sizing: border-box;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- SETUP VIEW -->
    <div id="setupView" class="fade-in">
      <h1>Latin Verb Practice Game</h1>
      <p>Select your filters and number of rounds, then click "Start Practice".</p>
      
      <!-- Hidden principal parts boxes (auto-filled) -->
      <div class="input-group hidden">
        <label for="pp1">Principal Part 1:</label>
        <input type="text" id="pp1" readonly>
      </div>
      <div class="input-group hidden">
        <label for="pp2">Principal Part 2:</label>
        <input type="text" id="pp2" readonly>
      </div>
      <div class="input-group hidden">
        <label for="pp3">Principal Part 3:</label>
        <input type="text" id="pp3" readonly>
      </div>
      <div class="input-group hidden">
        <label for="pp4">Principal Part 4:</label>
        <input type="text" id="pp4" readonly>
      </div>
      
      <!-- Filter Options -->
      <fieldset>
        <legend>Mood</legend>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterMood" value="indicative" checked> Indicative</label>
        </div>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterMood" value="subjunctive" checked> Subjunctive</label>
        </div>
      </fieldset>
      <fieldset>
        <legend>Tense</legend>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterTense" value="present" checked> Present</label>
        </div>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterTense" value="imperfect" checked> Imperfect</label>
        </div>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterTense" value="future" checked> Future</label>
        </div>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterTense" value="perfect" checked> Perfect</label>
        </div>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterTense" value="pluperfect" checked> Pluperfect</label>
        </div>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterTense" value="futureperfect" checked> Future Perfect</label>
        </div>
      </fieldset>
      <fieldset>
        <legend>Voice</legend>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterVoice" value="active" checked> Active</label>
        </div>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterVoice" value="passive" checked> Passive</label>
        </div>
      </fieldset>
      <fieldset>
        <legend>Person</legend>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterPerson" value="1" checked> 1</label>
        </div>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterPerson" value="2" checked> 2</label>
        </div>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterPerson" value="3" checked> 3</label>
        </div>
      </fieldset>
      <fieldset>
        <legend>Number</legend>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterNumber" value="s" checked> Singular</label>
        </div>
        <div class="checkbox-group">
          <label><input type="checkbox" name="filterNumber" value="p" checked> Plural</label>
        </div>
      </fieldset>
      <fieldset>
        <legend>Number of Rounds</legend>
        <div class="radio-group">
          <label><input type="radio" name="roundCount" value="5" checked> 5</label>
        </div>
        <div class="radio-group">
          <label><input type="radio" name="roundCount" value="10"> 10</label>
        </div>
        <div class="radio-group">
          <label><input type="radio" name="roundCount" value="15"> 15</label>
        </div>
        <div class="radio-group">
          <label><input type="radio" name="roundCount" value="20"> 20</label>
        </div>
        <div class="radio-group">
          <label><input type="radio" name="roundCount" value="25"> 25</label>
        </div>
      </fieldset>
      <button id="startPracticeBtn">Start Practice</button>
    </div>
    
    <!-- PRACTICE VIEW -->
    <div id="practiceView" class="hidden fade-in">
      <div id="topBar">
        <span id="scoreDisplay">Score: 0 / 0</span>
        <span id="timerDisplay">Time: 0s</span>
      </div>
      <div id="questionDisplay">
        <h2 id="verbFormDisplay"></h2>
        <div id="principalPartsDisplay"></div>
      </div>
      <!-- Answer option containers in the order: Person, Number, Tense, Voice, Mood -->
      <div id="answerChoices">
        <div class="practice-option" id="optionPerson">
          <h3>Person</h3>
        </div>
        <div class="practice-option" id="optionNumber">
          <h3>Number</h3>
        </div>
        <div class="practice-option" id="optionTense">
          <h3>Tense</h3>
        </div>
        <div class="practice-option" id="optionVoice">
          <h3>Voice</h3>
        </div>
        <div class="practice-option" id="optionMood">
          <h3>Mood</h3>
        </div>
      </div>
      <div id="correctAnswerDisplay"></div>
      <button id="checkAnswerBtn">Check Answer</button>
    </div>
    
    <!-- FINAL VIEW -->
    <div id="finalView" class="hidden fade-in">
      <h1>Session Complete!</h1>
      <p id="finalScoreDisplay"></p>
      <p id="finalTimeDisplay"></p>
      <h2>Review of Your Answers</h2>
      <table id="recordTable">
        <thead>
          <tr>
            <th>#</th>
            <th>Verb (Principal Parts)</th>
            <th>Your Answer</th>
            <th>Correct Answer</th>
            <th>Result</th>
          </tr>
        </thead>
        <tbody id="recordTableBody">
          <!-- Records inserted dynamically -->
        </tbody>
      </table>
      <button id="restartBtn">Restart</button>
    </div>
    
    <!-- Confetti Canvas -->
    <canvas id="confettiCanvas" class="confetti hidden"></canvas>
  </div>
  
  <!-- JAVASCRIPT -->
  <script>
    /***********************
     * FULL VERB CONJUGATION LOGIC
     ***********************/
    // Utility: Remove diacritics
    function removeDiacritics(str) {
      return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    }
    
    // Generic Endings
    const genericEndings = {
      indicative: {
        active: {
          perfect: ["i", "isti", "it", "imus", "istis", "erunt"],
          pluperfect: ["eram", "eras", "erat", "eramus", "eratis", "erant"],
          futurePerfect: ["ero", "eris", "erit", "erimus", "eritis", "erint"]
        },
        passive: {
          perfect: ["sum", "es", "est", "sumus", "estis", "sunt"],
          pluperfect: ["eram", "eras", "erat", "eramus", "eratis", "erant"],
          futurePerfect: ["ero", "eris", "erit", "erimus", "eritis", "erint"]
        }
      },
      subjunctive: {
        active: {
          perfect: ["erim", "eris", "erit", "erimus", "eritis", "erint"],
          pluperfect: ["issem", "isses", "isset", "issemus", "issetis", "issent"]
        },
        passive: {
          perfect: ["sim", "sis", "sit", "simus", "sitis", "sint"],
          pluperfect: ["essem", "esses", "esset", "essemus", "essetis", "essent"]
        }
      }
    };
    
    /***********************
     * CONJUGATION 1 (1st Conjugation)
     ***********************/
    function getPresentStem1(pp2) {
      return removeDiacritics(pp2).slice(0, -2);
    }
    function getPerfectStem1(pp3) {
      return removeDiacritics(pp3).slice(0, -1);
    }
    function getSubjunctiveStem1(pp1, pp2) {
      let stem = getPresentStem1(pp2);
      return stem.replace(/a$/, "e");
    }
    function getPassiveStem1(pp1, pp2, person, number, tense) {
      let stem = getPresentStem1(pp2);
      if (tense === "present") {
        return (person === "1" && number === "s") ? stem.slice(0, -1) : stem;
      } else {
        return stem;
      }
    }
    const endings1 = {
      indicative: {
        active: {
          present: ["o", "s", "t", "mus", "tis", "nt"],
          imperfect: ["bam", "bas", "bat", "bamus", "batis", "bant"],
          future: ["bo", "bis", "bit", "bimus", "bitis", "bunt"],
          perfect: ["i", "isti", "it", "imus", "istis", "erunt"],
          pluperfect: ["eram", "eras", "erat", "eramus", "eratis", "erant"],
          futurePerfect: ["ero", "eris", "erit", "erimus", "eritis", "erint"]
        },
        passive: {
          present: ["or", "ris", "tur", "mur", "mini", "ntur"],
          imperfect: ["bar", "baris", "batur", "bamur", "bamini", "bantur"],
          future: ["bor", "beris", "bitur", "bimur", "bimini", "buntur"],
          perfect: ["sum", "es", "est", "sumus", "estis", "sunt"],
          pluperfect: ["eram", "eras", "erat", "eramus", "eratis", "erant"],
          futurePerfect: ["ero", "eris", "erit", "erimus", "eritis", "erint"]
        }
      },
      subjunctive: {
        active: {
          present: ["m", "s", "t", "mus", "tis", "nt"],
          imperfect: ["rem", "res", "ret", "remus", "retis", "rent"],
          perfect: ["erim", "eris", "erit", "erimus", "eritis", "erint"],
          pluperfect: ["issem", "isses", "isset", "issemus", "issetis", "issent"]
        },
        passive: {
          present: ["ar", "aris", "atur", "amur", "amini", "antur"],
          imperfect: ["rer", "reris", "retur", "remur", "remini", "rentur"],
          perfect: ["sim", "sis", "sit", "simus", "sitis", "sint"],
          pluperfect: ["essem", "esses", "esset", "essemus", "essetis", "essent"]
        }
      }
    };
    function conjugateVerb1(pp1, pp2, pp3, pp4, mood, tense, voice, person, number) {
      const idx = { "1s": 0, "2s": 1, "3s": 2, "1p": 3, "2p": 4, "3p": 5 }[person + number];
      const presentSystem = ["present", "imperfect", "future"];
      const perfectSystem = ["perfect", "pluperfect", "futurePerfect"];
      
      if (voice === "active") {
        let stem = "";
        if (mood === "indicative" || mood === "subjunctive") {
          if (tense === "present") {
            if (mood === "subjunctive") {
              stem = getSubjunctiveStem1(pp1, pp2);
            } else {
              let tempStem = getPresentStem1(pp2);
              stem = (person === "1" && number === "s") ? tempStem.slice(0, -1) : tempStem;
            }
          } else if (["imperfect", "future"].includes(tense)) {
            stem = getPresentStem1(pp2);
          } else if (perfectSystem.includes(tense)) {
            stem = getPerfectStem1(pp3);
          }
        }
        let ending = endings1[mood].active[tense][idx];
        return stem + ending;
      } else if (voice === "passive") {
        if (presentSystem.includes(tense)) {
          if (mood === "subjunctive" && tense === "present") {
            const customEndings = { "1s": "er", "2s": "eris", "3s": "etur", "1p": "mur", "2p": "mini", "3p": "entur" };
            let baseStem = removeDiacritics(pp2).slice(0, -2);
            let resultStem = (number === "s") ? baseStem.slice(0, -1) :
              ((person === "1" || person === "2") ? baseStem.slice(0, -1) + "e" : baseStem.slice(0, -1));
            return resultStem + customEndings[person + number];
          } else {
            let stem = getPassiveStem1(pp1, pp2, person, number, tense);
            let ending = (mood === "indicative") ? endings1.indicative.passive[tense][idx]
                                                 : endings1.subjunctive.passive[tense][idx];
            return stem + ending;
          }
        } else if (perfectSystem.includes(tense)) {
          let participle = (number === "s") ?
            removeDiacritics(pp4).replace(/(um|us)$/i, "us") :
            removeDiacritics(pp4).replace(/(us|um)$/i, "i");
          let aux = (mood === "indicative") ? endings1.indicative.passive[tense][idx]
                                             : endings1.subjunctive.passive[tense][idx];
          return participle + " " + aux;
        }
      }
      return "";
    }
    
    /***********************
     * CONJUGATION 2 (2nd Conjugation)
     ***********************/
    function getPresentStem2(pp2) {
      return removeDiacritics(pp2).slice(0, -2);
    }
    function getPerfectStem2(pp3) {
      return removeDiacritics(pp3).slice(0, -1);
    }
    function getSubjunctiveStem2(pp1, pp2) {
      let stem = getPresentStem2(pp2);
      return stem + "a";
    }
    function getPassiveStem2(pp1, pp2) {
      return getPresentStem2(pp2);
    }
    const endings2 = {
      indicative: {
        active: {
          present: ["o", "s", "t", "mus", "tis", "nt"],
          imperfect: ["bam", "bas", "bat", "bamus", "batis", "bant"],
          future: ["bo", "bis", "bit", "bimus", "bitis", "bunt"],
          perfect: ["i", "isti", "it", "imus", "istis", "erunt"],
          pluperfect: ["eram", "eras", "erat", "eramus", "eratis", "erant"],
          futurePerfect: ["ero", "eris", "erit", "erimus", "eritis", "erint"]
        },
        passive: {
          present: ["or", "ris", "tur", "mur", "mini", "ntur"],
          imperfect: ["bar", "baris", "batur", "bamur", "bamini", "bantur"],
          future: ["bor", "beris", "bitur", "bimur", "bimini", "buntur"],
          perfect: ["sum", "es", "est", "sumus", "estis", "sunt"],
          pluperfect: ["eram", "eras", "erat", "eramus", "eratis", "erant"],
          futurePerfect: ["ero", "eris", "erit", "erimus", "eritis", "erint"]
        }
      },
      subjunctive: {
        active: {
          present: ["m", "s", "t", "mus", "tis", "nt"],
          imperfect: ["rem", "res", "ret", "remus", "retis", "rent"],
          perfect: ["erim", "eris", "erit", "erimus", "eritis", "erint"],
          pluperfect: ["issem", "isses", "isset", "issemus", "issetis", "issent"]
        },
        passive: {
          present: ["ar", "aris", "atur", "amur", "amini", "antur"],
          imperfect: ["rer", "reris", "retur", "remur", "remini", "rentur"],
          perfect: ["sim", "sis", "sit", "simus", "sitis", "sint"],
          pluperfect: ["essem", "esses", "esset", "essemus", "essetis", "essent"]
        }
      }
    };
    function conjugateVerb2(pp1, pp2, pp3, pp4, mood, tense, voice, person, number) {
      const idx = { "1s": 0, "2s": 1, "3s": 2, "1p": 3, "2p": 4, "3p": 5 }[person + number];
      const presentSystem = ["present", "imperfect", "future"];
      const perfectSystem = ["perfect", "pluperfect", "futurePerfect"];
      
      if (voice === "active") {
        let stem = "";
        if (mood === "indicative" || mood === "subjunctive") {
          if (tense === "present") {
            stem = (mood === "subjunctive") ? getSubjunctiveStem2(pp1, pp2) : getPresentStem2(pp2);
          } else if (["imperfect", "future"].includes(tense)) {
            stem = getPresentStem2(pp2);
          } else if (perfectSystem.includes(tense)) {
            stem = getPerfectStem2(pp3);
          }
        }
        let ending = endings2[mood].active[tense][idx];
        return stem + ending;
      } else if (voice === "passive") {
        if (presentSystem.includes(tense)) {
          let stem = getPassiveStem2(pp1, pp2);
          let ending = (mood === "indicative") ? endings2.indicative.passive[tense][idx]
                                               : endings2.subjunctive.passive[tense][idx];
          return stem + ending;
        } else if (perfectSystem.includes(tense)) {
          let participle = (number === "s") ?
            removeDiacritics(pp4).replace(/(um|us)$/i, "us") :
            removeDiacritics(pp4).replace(/(us|um)$/i, "i");
          let aux = (mood === "indicative") ? endings2.indicative.passive[tense][idx]
                                             : endings2.subjunctive.passive[tense][idx];
          return participle + " " + aux;
        }
      }
      return "";
    }
    
    /***********************
     * CONJUGATION 3 (3rd Conjugation)
     ***********************/
    function getPresentStem3(pp2) {
      return removeDiacritics(pp2).slice(0, -3);
    }
    function getPerfectStem3(pp3) {
      return removeDiacritics(pp3).slice(0, -1);
    }
    function getSubjunctiveStem3(pp1, pp2) {
      let stem = getPresentStem3(pp2);
      return stem + "a";
    }
    function getPassiveStem3(pp1, pp2) {
      return getPresentStem3(pp2);
    }
    const endings3rdActivePresent    = ["o", "is", "it", "imus", "itis", "unt"];
    const endings3rdActiveImperfect  = ["ebam", "ebas", "ebat", "ebamus", "ebatis", "ebant"];
    const endings3rdActiveFuture     = ["am", "es", "et", "emus", "etis", "ent"];
    const endings3rdActiveSubjunctiveCorrect = ["am", "as", "at", "amus", "atis", "ant"];
    const endings3rdActiveImperfectSubjunctive = ["em", "es", "et", "emus", "etis", "ent"];
    
    const endings3rdPassiveSubjunctiveCorrect = ["ar", "aris", "atur", "amur", "amini", "antur"];
    const endings3rdPassivePresent   = ["or", "geris", "itur", "imur", "imini", "untur"];
    const endings3rdPassiveImperfect = ["ebar", "ebaris", "ebatur", "ebamur", "ebamini", "ebantur"];
    const endings3rdPassiveFuture    = ["ar", "eris", "etur", "emur", "emini", "entur"];
    function conjugateVerb3(pp1, pp2, pp3, pp4, mood, tense, voice, person, number) {
      const idx = { "1s": 0, "2s": 1, "3s": 2, "1p": 3, "2p": 4, "3p": 5 }[person + number];
      const presentSystem = ["present", "imperfect", "future"];
      const perfectSystem = ["perfect", "pluperfect", "futurePerfect"];
      
      if (perfectSystem.includes(tense)) {
        if (voice === "active") {
          let stem = getPerfectStem3(pp3);
          let ending = (mood === "indicative") ?
                       genericEndings.indicative.active[tense][idx] :
                       genericEndings.subjunctive.active[tense][idx];
          return stem + ending;
        } else if (voice === "passive") {
          let participle = (number === "s") ?
            removeDiacritics(pp4).replace(/(um|us)$/i, "us") :
            removeDiacritics(pp4).replace(/(us|um)$/i, "i");
          let aux = (mood === "indicative") ?
                    genericEndings.indicative.passive[tense][idx] :
                    genericEndings.subjunctive.passive[tense][idx];
          return participle + " " + aux;
        }
      }
      
      if (presentSystem.includes(tense)) {
        if (voice === "active") {
          if (tense === "present") {
            if (mood === "indicative") {
              if (person === "1" && number === "s") {
                return removeDiacritics(pp1);
              } else {
                return getPresentStem3(pp2) + { "2s": "is", "3s": "it", "1p": "imus", "2p": "itis", "3p": "unt" }[person+number];
              }
            } else if (mood === "subjunctive") {
              return getPresentStem3(pp2) + endings3rdActiveSubjunctiveCorrect[idx];
            }
          } else if (tense === "imperfect") {
            if (mood === "indicative") {
              return getPresentStem3(pp2) + endings3rdActiveImperfect[idx];
            } else if (mood === "subjunctive") {
              let stem = getPresentStem3(pp2) + "er";
              return stem + endings3rdActiveImperfectSubjunctive[idx];
            }
          } else if (tense === "future") {
            return getPresentStem3(pp2) + endings3rdActiveFuture[idx];
          }
        } else if (voice === "passive") {
          if (tense === "present") {
            if (mood === "indicative") {
              let stem = getPassiveStem3(pp1, pp2);
              let ending = endings3rdPassivePresent[idx];
              if (person === "2" && number === "s") {
                ending = ending.substring(1);
              }
              return stem + ending;
            } else if (mood === "subjunctive") {
              return getPassiveStem3(pp1, pp2) + endings3rdPassiveSubjunctiveCorrect[idx];
            }
          } else if (tense === "imperfect") {
            if (mood === "indicative") {
              return getPassiveStem3(pp1, pp2) + endings3rdPassiveImperfect[idx];
            } else if (mood === "subjunctive") {
              let stem = removeDiacritics(pp2).slice(0, -2);
              const customEndings = { "1s": "rer", "2s": "reris", "3s": "retur", "1p": "remur", "2p": "remini", "3p": "rentur" };
              return stem + customEndings[person+number];
            }
          } else if (tense === "future") {
            return getPassiveStem3(pp1, pp2) + endings3rdPassiveFuture[idx];
          }
        }
      }
      return "";
    }
    
    /***********************
     * CONJUGATION 3‑io (3rd‑io Conjugation)
     ***********************/
    function getPresentStem3io(pp1) {
      return removeDiacritics(pp1).slice(0, -1);
    }
    function getPerfectStem3io(pp3) {
      return removeDiacritics(pp3).slice(0, -1);
    }
    function getPassivePresentIndicative3io(pp1, person, number) {
      let stem = getPresentStem3io(pp1);
      if (person === "1" && number === "s") {
        return stem.slice(0, -1) + "ior";
      } else if (person === "2" && number === "s") {
        return stem.slice(0, -1) + "eris";
      } else if (person === "3" && number === "s") {
        return stem + "tur";
      } else if (person === "1" && number === "p") {
        return stem + "mur";
      } else if (person === "2" && number === "p") {
        return stem + "mini";
      } else if (person === "3" && number === "p") {
        return stem + "untur";
      }
      return "";
    }
    function getPassivePresentSubjunctive3io(pp1, person, number) {
      let stem = getPresentStem3io(pp1);
      if (person === "1" && number === "s") {
        return stem + "ar";
      } else if (person === "2" && number === "s") {
        return stem + "as";
      } else if (person === "3" && number === "s") {
        return stem + "at";
      } else if (person === "1" && number === "p") {
        return stem + "amus";
      } else if (person === "2" && number === "p") {
        return stem + "atis";
      } else if (person === "3" && number === "p") {
        return stem + "ant";
      }
      return "";
    }
    function conjugateVerb3io(pp1, pp2, pp3, pp4, mood, tense, voice, person, number) {
      const idx = { "1s": 0, "2s": 1, "3s": 2, "1p": 3, "2p": 4, "3p": 5 }[person + number];
      const presentSystem = ["present", "imperfect", "future"];
      const perfectSystem = ["perfect", "pluperfect", "futurePerfect"];
      
      if (perfectSystem.includes(tense)) {
        if (voice === "active") {
          let stem = getPerfectStem3io(pp3);
          let ending = (mood === "indicative") ?
                       genericEndings.indicative.active[tense][idx] :
                       genericEndings.subjunctive.active[tense][idx];
          return stem + ending;
        } else if (voice === "passive") {
          let participle = (number === "s") ?
            removeDiacritics(pp4).replace(/(um|us)$/i, "us") :
            removeDiacritics(pp4).replace(/(us|um)$/i, "i");
          let aux = (mood === "indicative") ?
                    genericEndings.indicative.passive[tense][idx] :
                    genericEndings.subjunctive.passive[tense][idx];
          return participle + " " + aux;
        }
      }
      
      if (presentSystem.includes(tense)) {
        if (voice === "active") {
          if (tense === "present") {
            if (mood === "indicative") {
              if (person === "1" && number === "s") {
                return removeDiacritics(pp1);
              } else {
                return getPresentStem3io(pp1) + { "2s": "s", "3s": "t", "1p": "mus", "2p": "tis", "3p": "unt" }[person+number];
              }
            } else if (mood === "subjunctive") {
              return getPresentStem3io(pp1) + ["am", "as", "at", "amus", "atis", "ant"][idx];
            }
          } else if (tense === "imperfect") {
            if (mood === "indicative") {
              return getPresentStem3io(pp1) + ["ebam", "ebas", "ebat", "ebamus", "ebatis", "ebant"][idx];
            } else if (mood === "subjunctive") {
              let stem = removeDiacritics(pp2).slice(0, -2);
              return stem + ["rem", "res", "ret", "remus", "retis", "rent"][idx];
            }
          } else if (tense === "future") {
            return getPresentStem3io(pp1) + ["am", "es", "et", "emus", "etis", "ent"][idx];
          }
        } else if (voice === "passive") {
          if (tense === "present") {
            if (mood === "indicative") {
              return getPassivePresentIndicative3io(pp1, person, number);
            } else if (mood === "subjunctive") {
              return getPassivePresentSubjunctive3io(pp1, person, number);
            }
          } else if (tense === "imperfect") {
            if (mood === "indicative") {
              return getPresentStem3io(pp1) + ["ebar", "ebaris", "ebatur", "ebamur", "ebamini", "ebantur"][idx];
            } else if (mood === "subjunctive") {
              let stem = removeDiacritics(pp2).slice(0, -2);
              return stem + ["rer", "reris", "retur", "remur", "remini", "rentur"][idx];
            }
          } else if (tense === "future") {
            return getPresentStem3io(pp1) + ["ar", "eris", "etur", "emur", "emini", "entur"][idx];
          }
        }
      }
      return "";
    }
    
    /***********************
     * CONJUGATION 4 (4th Conjugation)
     ***********************/
    function getPresentStem4(pp1) {
      return removeDiacritics(pp1).slice(0, -1);
    }
    function getPerfectStem4(pp3) {
      return removeDiacritics(pp3).slice(0, -1);
    }
    function getPassivePresentIndicative4(pp1, person, number) {
      let stem = getPresentStem4(pp1);
      if (person === "1" && number === "s") {
        return stem.slice(0, -1) + "ior";
      } else if (person === "2" && number === "s") {
        return stem.slice(0, -1) + "iris";
      } else if (person === "3" && number === "s") {
        return stem + "tur";
      } else if (person === "1" && number === "p") {
        return stem + "mur";
      } else if (person === "2" && number === "p") {
        return stem + "mini";
      } else if (person === "3" && number === "p") {
        return stem + "untur";
      }
      return "";
    }
    function getPassivePresentSubjunctive4(pp1, person, number) {
      let stem = getPresentStem4(pp1);
      if (person === "1" && number === "s") {
        return stem + "ar";
      } else if (person === "2" && number === "s") {
        return stem + "aris";
      } else if (person === "3" && number === "s") {
        return stem + "atur";
      } else if (person === "1" && number === "p") {
        return stem + "amur";
      } else if (person === "2" && number === "p") {
        return stem + "amini";
      } else if (person === "3" && number === "p") {
        return stem + "antur";
      }
      return "";
    }
    const endings4thActivePresent = { "2s": "s", "3s": "t", "1p": "mus", "2p": "tis", "3p": "unt" };
    const endings4thActiveImperfectIndicative = ["ebam", "ebas", "ebat", "ebamus", "ebatis", "ebant"];
    const endings4thActiveFuture = ["am", "es", "et", "emus", "etis", "ent"];
    const endings4thActiveSubjunctive = ["am", "as", "at", "amus", "atis", "ant"];
    const endings4thActiveImperfectSubjunctive = ["rem", "res", "ret", "remus", "retis", "rent"];
    
    const endings4thPassiveImperfectIndicative = ["ebar", "ebaris", "ebatur", "ebamur", "ebamini", "ebantur"];
    const endings4thPassiveFuture = ["ar", "eris", "etur", "emur", "emini", "entur"];
    const endings4thPassiveImperfectSubjunctive = ["rer", "reris", "retur", "remur", "remini", "rentur"];
    function conjugateVerb4(pp1, pp2, pp3, pp4, mood, tense, voice, person, number) {
      const idx = { "1s": 0, "2s": 1, "3s": 2, "1p": 3, "2p": 4, "3p": 5 }[person + number];
      const presentSystem = ["present", "imperfect", "future"];
      const perfectSystem = ["perfect", "pluperfect", "futurePerfect"];
      
      if (voice === "active") {
        if (presentSystem.includes(tense)) {
          if (tense === "present") {
            if (mood === "indicative") {
              if (person === "1" && number === "s") {
                return removeDiacritics(pp1);
              } else {
                return getPresentStem4(pp1) + endings4thActivePresent[person+number];
              }
            } else if (mood === "subjunctive") {
              return getPresentStem4(pp1) + endings4thActiveSubjunctive[idx];
            }
          } else if (tense === "imperfect") {
            if (mood === "indicative") {
              return getPresentStem4(pp1) + endings4thActiveImperfectIndicative[idx];
            } else if (mood === "subjunctive") {
              let stem = removeDiacritics(pp2).slice(0, -2);
              return stem + endings4thActiveImperfectSubjunctive[idx];
            }
          } else if (tense === "future") {
            return getPresentStem4(pp1) + endings4thActiveFuture[idx];
          }
        }
        if (perfectSystem.includes(tense)) {
          let stem = getPerfectStem4(pp3);
          let ending = (mood === "indicative") ?
                       genericEndings.indicative.active[tense][idx] :
                       genericEndings.subjunctive.active[tense][idx];
          return stem + ending;
        }
      } else if (voice === "passive") {
        if (presentSystem.includes(tense)) {
          if (tense === "present") {
            if (mood === "indicative") {
              return getPassivePresentIndicative4(pp1, person, number);
            } else if (mood === "subjunctive") {
              return getPassivePresentSubjunctive4(pp1, person, number);
            }
          } else if (tense === "imperfect") {
            if (mood === "indicative") {
              return getPresentStem4(pp1) + endings4thPassiveImperfectIndicative[idx];
            } else if (mood === "subjunctive") {
              let stem = removeDiacritics(pp2).slice(0, -2);
              return stem + endings4thPassiveImperfectSubjunctive[idx];
            }
          } else if (tense === "future") {
            return getPresentStem4(pp1) + endings4thPassiveFuture[idx];
          }
        }
        if (perfectSystem.includes(tense)) {
          let participle = (number === "s") ?
            removeDiacritics(pp4).replace(/(um|us)$/i, "us") :
            removeDiacritics(pp4).replace(/(us|um)$/i, "i");
          let aux = (mood === "indicative") ?
              genericEndings.indicative.passive[tense][idx] :
              genericEndings.subjunctive.passive[tense][idx];
          return participle + " " + aux;
        }
      }
      return "";
    }
    
    /***********************
     * AUTO-DETECTION FUNCTION
     ***********************/
    function autoDetectConjugation(pp1, pp2) {
      let infinitive = pp2.toLowerCase().trim();
      let part1 = pp1.toLowerCase().trim();
      if (infinitive.endsWith("are")) {
        return "1"; // 1st conjugation
      } else if (infinitive.endsWith("ire")) {
        return "4"; // 4th conjugation
      } else if (infinitive.endsWith("ere")) {
        if (part1.endsWith("eo")) return "2";
        else if (part1.endsWith("io")) return "3io";
        else return "3";
      }
      return "unknown";
    }
    
    /***********************
     * FUNCTIONS TO GET ARRAY OF FORM OBJECTS FOR EACH CONJUGATION
     ***********************/
    function getForms1(pp1, pp2, pp3, pp4) {
      const moods = ["indicative", "subjunctive"];
      const indicativeTenses = ["present", "imperfect", "future", "perfect", "pluperfect", "futurePerfect"];
      const subjunctiveTenses = ["present", "imperfect", "perfect", "pluperfect"];
      const voices = ["active", "passive"];
      const persons = ["1", "2", "3"];
      const numbers = ["s", "p"];
      let forms = [];
      moods.forEach(mood => {
        const tenses = (mood === "indicative") ? indicativeTenses : subjunctiveTenses;
        tenses.forEach(tense => {
          voices.forEach(voice => {
            persons.forEach(person => {
              numbers.forEach(number => {
                const form = conjugateVerb1(pp1, pp2, pp3, pp4, mood, tense, voice, person, number);
                forms.push({ mood, tense, voice, person, number, form });
              });
            });
          });
        });
      });
      return forms;
    }
    
    function getForms2(pp1, pp2, pp3, pp4) {
      const moods = ["indicative", "subjunctive"];
      const indicativeTenses = ["present", "imperfect", "future", "perfect", "pluperfect", "futurePerfect"];
      const subjunctiveTenses = ["present", "imperfect", "perfect", "pluperfect"];
      const voices = ["active", "passive"];
      const persons = ["1", "2", "3"];
      const numbers = ["s", "p"];
      let forms = [];
      moods.forEach(mood => {
        const tenses = (mood === "indicative") ? indicativeTenses : subjunctiveTenses;
        tenses.forEach(tense => {
          voices.forEach(voice => {
            persons.forEach(person => {
              numbers.forEach(number => {
                const form = conjugateVerb2(pp1, pp2, pp3, pp4, mood, tense, voice, person, number);
                forms.push({ mood, tense, voice, person, number, form });
              });
            });
          });
        });
      });
      return forms;
    }
    
    function getForms3(pp1, pp2, pp3, pp4) {
      const moods = ["indicative", "subjunctive"];
      const indicativeTenses = ["present", "imperfect", "future", "perfect", "pluperfect", "futurePerfect"];
      const subjunctiveTenses = ["present", "imperfect", "perfect", "pluperfect"];
      const voices = ["active", "passive"];
      const persons = ["1", "2", "3"];
      const numbers = ["s", "p"];
      let forms = [];
      moods.forEach(mood => {
        const tenses = (mood === "indicative") ? indicativeTenses : subjunctiveTenses;
        tenses.forEach(tense => {
          voices.forEach(voice => {
            persons.forEach(person => {
              numbers.forEach(number => {
                const form = conjugateVerb3(pp1, pp2, pp3, pp4, mood, tense, voice, person, number);
                forms.push({ mood, tense, voice, person, number, form });
              });
            });
          });
        });
      });
      return forms;
    }
    
    function getForms3io(pp1, pp2, pp3, pp4) {
      const moods = ["indicative", "subjunctive"];
      const indicativeTenses = ["present", "imperfect", "future", "perfect", "pluperfect", "futurePerfect"];
      const subjunctiveTenses = ["present", "imperfect", "perfect", "pluperfect"];
      const voices = ["active", "passive"];
      const persons = ["1", "2", "3"];
      const numbers = ["s", "p"];
      let forms = [];
      moods.forEach(mood => {
        const tenses = (mood === "indicative") ? indicativeTenses : subjunctiveTenses;
        tenses.forEach(tense => {
          voices.forEach(voice => {
            persons.forEach(person => {
              numbers.forEach(number => {
                const form = conjugateVerb3io(pp1, pp2, pp3, pp4, mood, tense, voice, person, number);
                forms.push({ mood, tense, voice, person, number, form });
              });
            });
          });
        });
      });
      return forms;
    }
    
    function getForms4(pp1, pp2, pp3, pp4) {
      const moods = ["indicative", "subjunctive"];
      const indicativeTenses = ["present", "imperfect", "future", "perfect", "pluperfect", "futurePerfect"];
      const subjunctiveTenses = ["present", "imperfect", "perfect", "pluperfect"];
      const voices = ["active", "passive"];
      const persons = ["1", "2", "3"];
      const numbers = ["s", "p"];
      let forms = [];
      moods.forEach(mood => {
        const tenses = (mood === "indicative") ? indicativeTenses : subjunctiveTenses;
        tenses.forEach(tense => {
          voices.forEach(voice => {
            persons.forEach(person => {
              numbers.forEach(number => {
                const form = conjugateVerb4(pp1, pp2, pp3, pp4, mood, tense, voice, person, number);
                forms.push({ mood, tense, voice, person, number, form });
              });
            });
          });
        });
      });
      return forms;
    }
    
    /***********************
     * GAME STATE VARIABLES
     ***********************/
    let totalRounds = 0;
    let currentRound = 0;
    let sessionCorrectCount = 0;
    let currentAnswer = null;
    let answerRevealed = false;
    let sessionStartTime = null;
    let timerInterval = null;
    let sessionRecords = [];
    
    let allowedMood = [];
    let allowedTense = [];
    let allowedVoice = [];
    let allowedPerson = [];
    let allowedNumber = [];
    
    /***********************
     * TIMER FUNCTIONS
     ***********************/
    function startTimer() {
      sessionStartTime = Date.now();
      timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - sessionStartTime) / 1000);
        document.getElementById("timerDisplay").textContent = "Time: " + elapsed + "s";
      }, 1000);
    }
    function stopTimer() {
      clearInterval(timerInterval);
    }
    
    /***********************
     * UTILITY FUNCTIONS
     ***********************/
    function getCheckedValues(name) {
      const checkboxes = document.querySelectorAll('input[name="' + name + '"]:checked');
      return Array.from(checkboxes).map(cb => cb.value.toLowerCase());
    }
    function getSelectedRoundCount() {
      const radios = document.querySelectorAll('input[name="roundCount"]:checked');
      return radios.length ? parseInt(radios[0].value) : 5;
    }
    
    /***********************
     * SESSION INITIALIZATION & QUESTION GENERATION
     ***********************/
    function initializeSession() {
      allowedMood = getCheckedValues("filterMood");
      allowedTense = getCheckedValues("filterTense");
      allowedVoice = getCheckedValues("filterVoice");
      allowedPerson = getCheckedValues("filterPerson");
      allowedNumber = getCheckedValues("filterNumber");
      
      totalRounds = getSelectedRoundCount();
      currentRound = 0;
      sessionCorrectCount = 0;
      sessionRecords = [];
      answerRevealed = false;
      updateScoreDisplay();
      startTimer();
      nextQuestion();
    }
    
    function nextQuestion() {
      const randomVerb = verbLibrary[Math.floor(Math.random() * verbLibrary.length)].principalParts;
      document.getElementById("pp1").value = randomVerb[0];
      document.getElementById("pp2").value = randomVerb[1];
      document.getElementById("pp3").value = randomVerb[2];
      document.getElementById("pp4").value = randomVerb[3];
      
      const conjType = autoDetectConjugation(randomVerb[0], randomVerb[1]);
      let allForms = [];
      if (conjType === "1") {
        allForms = getForms1(randomVerb[0], randomVerb[1], randomVerb[2], randomVerb[3]);
      } else if (conjType === "2") {
        allForms = getForms2(randomVerb[0], randomVerb[1], randomVerb[2], randomVerb[3]);
      } else if (conjType === "3") {
        allForms = getForms3(randomVerb[0], randomVerb[1], randomVerb[2], randomVerb[3]);
      } else if (conjType === "3io") {
        allForms = getForms3io(randomVerb[0], randomVerb[1], randomVerb[2], randomVerb[3]);
      } else if (conjType === "4") {
        allForms = getForms4(randomVerb[0], randomVerb[1], randomVerb[2], randomVerb[3]);
      } else {
        allForms = getForms1(randomVerb[0], randomVerb[1], randomVerb[2], randomVerb[3]);
      }
      
      const filteredForms = allForms.filter(row =>
        allowedMood.includes(row.mood) &&
        allowedTense.includes(row.tense) &&
        allowedVoice.includes(row.voice) &&
        allowedPerson.includes(row.person) &&
        allowedNumber.includes(row.number)
      );
      
      if (filteredForms.length === 0) {
        alert("No forms available with the current filter settings. Please adjust your filters.");
        return;
      }
      
      currentAnswer = filteredForms[Math.floor(Math.random() * filteredForms.length)];
      answerRevealed = false;
      
      currentRound++;
      updateScoreDisplay();
      document.getElementById("verbFormDisplay").textContent = currentAnswer.form;
      document.getElementById("principalPartsDisplay").textContent = "(" + randomVerb.join(", ") + ")";
      document.getElementById("correctAnswerDisplay").textContent = "";
      
      // Generate option buttons in the order: Person, Number, Tense, Voice, Mood.
      generateOptionButtons("optionPerson", allowedPerson, currentAnswer.person);
      generateOptionButtons("optionNumber", allowedNumber, currentAnswer.number);
      generateOptionButtons("optionTense", allowedTense, currentAnswer.tense);
      generateOptionButtons("optionVoice", allowedVoice, currentAnswer.voice);
      generateOptionButtons("optionMood", allowedMood, currentAnswer.mood);
      
      document.getElementById("checkAnswerBtn").textContent = "Check Answer";
    }
    
    function updateScoreDisplay() {
      document.getElementById("scoreDisplay").textContent = "Score: " + sessionCorrectCount + " / " + (currentRound - 1);
    }
    
    /***********************
     * DYNAMIC OPTION BUTTON GENERATION
     ***********************/
    function generateOptionButtons(containerId, options, correctValue) {
      const container = document.getElementById(containerId);
      const headerText = container.querySelector("h3").textContent;
      container.innerHTML = "<h3>" + headerText + "</h3>";
      options.forEach(opt => {
        const btn = document.createElement("button");
        btn.textContent = opt;
        btn.dataset.value = opt;
        btn.classList.add("option-button");
        btn.addEventListener("click", function() {
          if (!answerRevealed) {
            Array.from(container.querySelectorAll("button")).forEach(b => b.classList.remove("selected"));
            btn.classList.add("selected");
          }
        });
        container.appendChild(btn);
      });
    }
    
    /***********************
     * ANSWER CHECKING
     ***********************/
    function isAnswerCorrect(selected, correct) {
      selected = selected.toLowerCase();
      correct = correct.toLowerCase();
      if (correct.indexOf("/") !== -1) {
        const possibilities = correct.split("/").map(s => s.trim());
        return possibilities.includes(selected);
      } else {
        return selected === correct;
      }
    }
    
    function checkAnswer() {
      if (!answerRevealed) {
        const selectedPerson = getSelectedOption("optionPerson");
        const selectedNumber = getSelectedOption("optionNumber");
        const selectedTense = getSelectedOption("optionTense");
        const selectedVoice = getSelectedOption("optionVoice");
        const selectedMood = getSelectedOption("optionMood");
        
        if (!selectedPerson || !selectedNumber || !selectedTense || !selectedVoice || !selectedMood) {
          alert("Please make a selection in every category.");
          return;
        }
        
        const personOk = isAnswerCorrect(selectedPerson, currentAnswer.person);
        const numberOk = isAnswerCorrect(selectedNumber, currentAnswer.number);
        const tenseOk = isAnswerCorrect(selectedTense, currentAnswer.tense);
        const voiceOk = isAnswerCorrect(selectedVoice, currentAnswer.voice);
        const moodOk = isAnswerCorrect(selectedMood, currentAnswer.mood);
        
        const isCorrect = personOk && numberOk && tenseOk && voiceOk && moodOk;
        
        const correctDisplay = "Correct Answer: " +
          "Person: " + currentAnswer.person + ", " +
          "Number: " + (currentAnswer.number === "s" ? "Singular" : "Plural") + ", " +
          "Tense: " + currentAnswer.tense + ", " +
          "Voice: " + currentAnswer.voice + ", " +
          "Mood: " + currentAnswer.mood;
        document.getElementById("correctAnswerDisplay").textContent = correctDisplay;
        
        flashFeedback(isCorrect);
        if (isCorrect) sessionCorrectCount++;
        updateScoreDisplay();
        answerRevealed = true;
        document.getElementById("checkAnswerBtn").textContent = "Next Verb";
        
        // Record this question for review.
        const record = {
          verb: document.getElementById("verbFormDisplay").textContent + " " +
                document.getElementById("principalPartsDisplay").textContent,
          studentAnswer: {
            person: selectedPerson,
            number: selectedNumber,
            tense: selectedTense,
            voice: selectedVoice,
            mood: selectedMood
          },
          correctAnswer: currentAnswer,
          result: isCorrect ? "Correct" : "Incorrect"
        };
        sessionRecords.push(record);
      } else {
        if (currentRound < totalRounds) {
          nextQuestion();
        } else {
          endSession();
        }
      }
    }
    
    function getSelectedOption(containerId) {
      const container = document.getElementById(containerId);
      const btn = container.querySelector("button.selected");
      return btn ? btn.dataset.value : null;
    }
    
    function flashFeedback(isCorrect) {
      const practiceView = document.getElementById("practiceView");
      const original = practiceView.style.backgroundColor;
      practiceView.style.backgroundColor = isCorrect ? "#c8e6c9" : "#ffcdd2";
      setTimeout(() => {
        practiceView.style.backgroundColor = original;
      }, 400);
    }
    
    /***********************
     * SESSION END & FINAL VIEW
     ***********************/
    function endSession() {
      stopTimer();
      document.getElementById("practiceView").classList.add("hidden");
      document.getElementById("finalView").classList.remove("hidden");
      document.getElementById("finalScoreDisplay").textContent = "Your Score: " + sessionCorrectCount + " / " + totalRounds;
      const elapsed = Math.floor((Date.now() - sessionStartTime) / 1000);
      document.getElementById("finalTimeDisplay").textContent = "Time Elapsed: " + elapsed + " seconds";
      buildRecordTable();
      
      if (sessionCorrectCount === totalRounds) {
        showConfetti();
        const optimeMsg = document.createElement("h1");
        optimeMsg.textContent = "Optime!";
        optimeMsg.style.color = "#2e7d32";
        optimeMsg.style.textAlign = "center";
        document.getElementById("finalView").appendChild(optimeMsg);
      }
    }
    
    function buildRecordTable() {
      const tbody = document.getElementById("recordTableBody");
      tbody.innerHTML = "";
      sessionRecords.forEach((record, index) => {
        const tr = document.createElement("tr");
        const tdNum = document.createElement("td");
        tdNum.textContent = index + 1;
        tr.appendChild(tdNum);
        const tdVerb = document.createElement("td");
        tdVerb.textContent = record.verb;
        tr.appendChild(tdVerb);
        const tdStudent = document.createElement("td");
        tdStudent.textContent = "Person: " + record.studentAnswer.person +
          ", Number: " + (record.studentAnswer.number === "s" ? "Singular" : "Plural") +
          ", Tense: " + record.studentAnswer.tense +
          ", Voice: " + record.studentAnswer.voice +
          ", Mood: " + record.studentAnswer.mood;
        tr.appendChild(tdStudent);
        const tdCorrect = document.createElement("td");
        tdCorrect.textContent = "Person: " + record.correctAnswer.person +
          ", Number: " + (record.correctAnswer.number === "s" ? "Singular" : "Plural") +
          ", Tense: " + record.correctAnswer.tense +
          ", Voice: " + record.correctAnswer.voice +
          ", Mood: " + record.correctAnswer.mood;
        tr.appendChild(tdCorrect);
        const tdResult = document.createElement("td");
        tdResult.textContent = record.result;
        tr.appendChild(tdResult);
        tbody.appendChild(tr);
      });
    }
    
    /***********************
     * SIMPLE CONFETTI (Demo Implementation)
     ***********************/
    function showConfetti() {
      const confettiCanvas = document.getElementById("confettiCanvas");
      confettiCanvas.classList.remove("hidden");
      const ctx = confettiCanvas.getContext("2d");
      confettiCanvas.width = window.innerWidth;
      confettiCanvas.height = window.innerHeight;
      
      let particles = [];
      for (let i = 0; i < 100; i++) {
        particles.push({
          x: Math.random() * confettiCanvas.width,
          y: Math.random() * confettiCanvas.height - confettiCanvas.height,
          r: Math.random() * 6 + 2,
          d: Math.random() * 30 + 1,
          color: "hsl(" + Math.floor(Math.random() * 360) + ", 100%, 50%)"
        });
      }
      
      function draw() {
        ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        particles.forEach(p => {
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2, true);
          ctx.closePath();
          ctx.fill();
        });
        update();
      }
      
      function update() {
        particles.forEach(p => {
          p.y += Math.cos(p.d) + 1 + p.r / 2;
          p.x += Math.sin(p.d);
          if (p.y > confettiCanvas.height) {
            p.y = 0;
            p.x = Math.random() * confettiCanvas.width;
          }
        });
      }
      
      let confettiInterval = setInterval(draw, 20);
      setTimeout(() => {
        clearInterval(confettiInterval);
        confettiCanvas.classList.add("hidden");
      }, 3000);
    }
    
    /***********************
     * EVENT LISTENERS
     ***********************/
    document.getElementById("startPracticeBtn").addEventListener("click", function() {
      // Fade-out setup view then show practice view
      const setupView = document.getElementById("setupView");
      setupView.classList.add("fade-out");
      setTimeout(() => {
        setupView.classList.add("hidden");
        setupView.classList.remove("fade-out");
        const practiceView = document.getElementById("practiceView");
        practiceView.classList.remove("hidden");
        practiceView.classList.add("fade-in");
        initializeSession();
      }, 5);
    });
    document.getElementById("checkAnswerBtn").addEventListener("click", checkAnswer);
    document.getElementById("restartBtn").addEventListener("click", function() {
      const finalView = document.getElementById("finalView");
      finalView.classList.add("fade-out");
      setTimeout(() => {
        finalView.classList.add("hidden");
        finalView.classList.remove("fade-out");
        const setupView = document.getElementById("setupView");
        setupView.classList.remove("hidden");
        setupView.classList.add("fade-in");
        // Clear extra messages
        const optimeMsg = finalView.querySelector("h1:not(:first-child)");
        if (optimeMsg) finalView.removeChild(optimeMsg);
      }, 5);
    });
    
    function getSelectedOption(containerId) {
      const container = document.getElementById(containerId);
      const btn = container.querySelector("button.selected");
      return btn ? btn.dataset.value : null;
    }
    
    /***********************
     * FULL VERB LIBRARY
     ***********************/
    const verbLibrary = [
      { principalParts: ["scio","scire","scivi","scitum"] },
      { principalParts: ["reperio","reperire","repperi","repertum"] },
      { principalParts: ["dormio","dormire","dormini","dormitum"] },
      { principalParts: ["venio","venire","veni","ventum"] },
      { principalParts: ["audio","audire","audivi","auditum"] },
      { principalParts: ["sentio","sentire","sensi","sensum"] },
      { principalParts: ["convenio","convenire","conveni","conventum"] },
      { principalParts: ["aperio","aperire","aperui","apertum"] },
      { principalParts: ["invenio","invenire","inveni","inventum"] },
      { principalParts: ["colo","colere","colui","cultum"] },
      { principalParts: ["cresco","crescere","crevi","cretum"] },
      { principalParts: ["curro","currere","cucurri","cursum"] },
      { principalParts: ["trado","tradere","tradidi","traditum"] },
      { principalParts: ["pendo","pendere","pependi","pensum"] },
      { principalParts: ["tego","tegere","tēxi","tēctum"] },
      { principalParts: ["fallo","fallere","fefelli","falsum"] },
      { principalParts: ["fundo","fundere","fudi","fusum"] },
      { principalParts: ["spargo","spargere","sparsi","sparsum"] },
      { principalParts: ["surgo","surgere","surrexi","surrectum"] },
      { principalParts: ["effundo","effundere","effudi","effusum"] },
      { principalParts: ["fluo","fluere","fluxi","fluxum"] },
      { principalParts: ["credo","credere","credidi","creditum"] },
      { principalParts: ["quaero","quaerere","quaesivi","quaesitum"] },
      { principalParts: ["cognosco","cognoscere","cognovi","cognitum"] },
      { principalParts: ["disco","discere","didici","discitum"] },
      { principalParts: ["intellego","intellegere","intellexi","intellectum"] },
      { principalParts: ["cerno","cernere","crevi","cretum"] },
      { principalParts: ["decerno","decernere","decrevi","decretum"] },
      { principalParts: ["contemno","contemnere","contempsi","contemptum"] },
      { principalParts: ["rideo","ridere","risi","risum"] },
      { principalParts: ["statuo","statuere","statui","statutum"] },
      { principalParts: ["vivo","vivere","vixi","victum"] },
      { principalParts: ["gigno","gignere","genui","genitum"] },
      { principalParts: ["alo","alere","alui","alitum"] },
      { principalParts: ["consumo","consumere","consumpsi","consumptum"] },
      { principalParts: ["quiesco","quiescere","quievi","quietum"] },
      { principalParts: ["diligo","diligere","dilexi","dilectum"] },
      { principalParts: ["compono","componere","composui","compositum"] },
      { principalParts: ["iungo","iungere","iunxi","iunctum"] },
      { principalParts: ["divido","dividere","divisi","divisum"] },
      { principalParts: ["constituo","constituere","constitui","constitutum"] },
      { principalParts: ["fingo","fingere","finxi","fictum"] },
      { principalParts: ["impono","imponere","imposui","impositum"] },
      { principalParts: ["peto","petere","petivi","petitum"] },
      { principalParts: ["relinquo","relinquere","reliqui","relictum"] },
      { principalParts: ["verto","vertere","verti","versum"] },
      { principalParts: ["sumo","sumere","sumpsi","sumptum"] },
      { principalParts: ["desero","deserere","deserui","desertum"] },
      { principalParts: ["procedo","procedere","processi","processum"] },
      { principalParts: ["pergo","pergere","perrexi","perrectum"] },
      { principalParts: ["converto","convertere","converti","conversum"] },
      { principalParts: ["intendo","intendere","intendi","intentum"] },
      { principalParts: ["adverto","advertere","adverti","adversum"] },
      { principalParts: ["reverto","revertere","reverti","reversum"] },
      { principalParts: ["ostendo","ostendere","ostendi","ostentum"] },
      { principalParts: ["tango","tangere","tetigi","tactum"] },
      { principalParts: ["mitto","mittere","misi","missum"] },
      { principalParts: ["dico","dicere","dixi","dictum"] },
      { principalParts: ["edo","edere","edidi","editum"] },
      { principalParts: ["rego","regere","rexi","rectum"] },
      { principalParts: ["eligo","eligere","elegi","electum"] },
      { principalParts: ["claudo","claudere","clausi","clausum"] },
      { principalParts: ["tendo","tendere","tetendi","tentum"] },
      { principalParts: ["veho","vehere","vexi","vectum"] },
      { principalParts: ["deduco","deducere","deduxi","deductum"] },
      { principalParts: ["descendo","descendere","descendi","descensum"] },
      { principalParts: ["ago","agere","egi","actum"] },
      { principalParts: ["duco","ducere","duxi","ductum"] },
      { principalParts: ["traho","trahere","traxi","tractum"] },
      { principalParts: ["cogo","cogere","coegi","coactum"] },
      { principalParts: ["sino","sinere","sivi","situm"] },
      { principalParts: ["pono","ponere","posui","positum"] },
      { principalParts: ["prodo","prodere","prodidi","proditum"] },
      { principalParts: ["cado","cadere","cecidi","casum"] },
      { principalParts: ["frango","frangere","fregi","fractum"] },
      { principalParts: ["rumpo","rumpere","rupi","ruptum"] },
      { principalParts: ["pello","pellere","pepuli","pulsum"] },
      { principalParts: ["caedo","caedere","cecidi","caesum"] },
      { principalParts: ["laedo","laedere","laesi","laesum"] },
      { principalParts: ["occido","occidere","occidi","occisum"] },
      { principalParts: ["vinco","vincere","vici","victum"] },
      { principalParts: ["gero","gerere","gessi","gestum"] },
      { principalParts: ["premo","premere","pressi","pressum"] },
      { principalParts: ["cedo","cedere","cessi","cessum"] },
      { principalParts: ["parco","parcere","peperci","parsum"] },
      { principalParts: ["defendo","defendere","defendi","defensum"] },
      { principalParts: ["cingo","cingere","cinxi","cinctum"] },
      { principalParts: ["cano","canere","cecini","cantum"] },
      { principalParts: ["lego","legere","legi","lectum"] },
      { principalParts: ["scribo","scribere","scripsi","scriptum"] },
      { principalParts: ["iacio","iacere","ieci","iactum"] },
      { principalParts: ["pario","parere","peperi","partum"] },
      { principalParts: ["cupio","cupere","cupivi","cupitum"] },
      { principalParts: ["facio","facere","feci","factum"] },
      { principalParts: ["incipio","incipere","incepi","inceptum"] },
      { principalParts: ["fugio","fugere","fugi","fugitum"] },
      { principalParts: ["recipio","recipere","recepi","receptum"] },
      { principalParts: ["eripio","eripere","eripui","ereptum"] },
      { principalParts: ["rapio","rapere","rapui","raptum"] },
      { principalParts: ["interficio","interficere","interfeci","interfectum"] },
      { principalParts: ["respicio","respicere","respexi","respectum"] },
      { principalParts: ["capio","capere","cepi","captum"] },
      { principalParts: ["ardeo","ardere","arsi","arsum"] },
      { principalParts: ["debeo","debere","debui","debitum"] },
      { principalParts: ["misceo","miscere","miscui","mixtum"] },
      { principalParts: ["doceo","docere","docui","doctum"] },
      { principalParts: ["censeo","censere","censui","censum"] },
      { principalParts: ["fleo","flere","flevi","fletum"] },
      { principalParts: ["terreo","terrere","terrui","territum"] },
      { principalParts: ["iubeo","iubere","iussi","iussum"] },
      { principalParts: ["augeo","augere","auxi","auctum"] },
      { principalParts: ["moveo","movere","movi","motum"] },
      { principalParts: ["habeo","habere","habui","habitum"] },
      { principalParts: ["teneo","tenere","tenui","tentum"] },
      { principalParts: ["taceo","tacere","tacui","tacitum"] },
      { principalParts: ["sustineo","sustinere","sustinui","sustentum"] },
      { principalParts: ["respondeo","respondere","respondi","responsum"] },
      { principalParts: ["moneo","monere","monui","monitum"] },
      { principalParts: ["persuadeo","persuadere","persuasi","persuasum"] },
      { principalParts: ["sedeo","sedere","sedi","sessum"] },
      { principalParts: ["solvo","solvere","solvi","solutum"] },
      { principalParts: ["maneo","manere","mansi","mansum"] },
      { principalParts: ["caveo","cavere","cavi","cautum"] },
      { principalParts: ["video","videre","vidi","visum"] },
      { principalParts: ["comparo","comparare","comparavi","comparatum"] },
      { principalParts: ["laboro","laborare","laboravi","laboratum"] },
      { principalParts: ["puto","putare","putavi","putatum"] },
      { principalParts: ["cogito","cogitare","cogitavi","cogitatum"] },
      { principalParts: ["existimo","existimare","exitimavi","existimatum"] },
      { principalParts: ["spero","sperare","speravi","speratum"] },
      { principalParts: ["damno","damnare","damnavi","damnatum"] },
      { principalParts: ["sto","stare","steti","statum"] },
      { principalParts: ["amo","amare","amavi","amatum"] },
      { principalParts: ["curo","curare","curavi","curatum"] },
      { principalParts: ["paro","parare","paravi","paratum"] },
      { principalParts: ["muto","mutare","mutavi","mutatum"] },
      { principalParts: ["tempto","temptare","temptavi","temptatum"] },
      { principalParts: ["porto","portare","portavi","portatum"] },
      { principalParts: ["oro","orare","oravi","oratum"] },
      { principalParts: ["do","dare","dedi","datum"] },
      { principalParts: ["iuvo","iuvare","iuvi","iutum"] },
      { principalParts: ["laudo","laudare","laudavi","laudatum"] },
      { principalParts: ["voco","vocare","vocavi","vocatum"] },
      { principalParts: ["nego","negare","negavi","negatum"] },
      { principalParts: ["rogo","rogare","rogavi","rogatum"] },
      { principalParts: ["narro","narrare","narravi","narratum"] },
      { principalParts: ["servo","servare","servavi","servatum"] },
      { principalParts: ["fugo","fugare","fugavi","fugatum"] },
      { principalParts: ["probo","probare","probavi","probatum"] },
      { principalParts: ["pugno","pugnare","pugnavi","pugnatum"] },
      { principalParts: ["exspecto","expectare","expectavi","expectatum"] },
      { principalParts: ["specto","spectare","spectavi","spectatum"] }
    ];
  </script>
</body>
</html>
